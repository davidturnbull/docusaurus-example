---
title: "Verifying signatures for POST requests"
sidebar_label: "POST requests"
path: /verify-post-request-signature/
---

When Canva sends a `POST` request to an app, it includes a comma-separated list of _request signatures_ in the HTTP headers, via the `X-Canva-Timestamp` header.

A request signature is a unique string of characters that identifies the request:

    e03c80881a48bb730cee12c7e842301b0b116b970a03068a5f5263358926e897

Your app is expected to:

1.  Calculate a signature for each request.
2.  Check if the calculated signature is found in the comma-separated list of signatures.
3.  Return a `401` status code if the calculated signature is **not** in the list of signatures.

:::note  
 Canva provides a list of signatures -- rather than just one signature -- to support _key rotation_. This allows you to [regenerate client secrets](./verifying-requests/#regenerating-a-client-secret.md) without causing downtime.  
:::

## Prerequisites

This tutorial assumes familiarity with JavaScript and Node.js. You should also be comfortable with the fundamentals of [content](./content-extensions.md) and [publish extensions](./publish-extensions.md).

## Step 1: Get your app's client secret

Every app has a _client secret_. This is a sensitive value that's shared between Canva and your app. You must use the secret to calculate a request signature.

To get your app's client secret:

1.  Navigate to an app via the Developer Portal.
2.  Open the **Verification & Auth** page.
3.  Under the **Client secret key** heading, click **Copy**.

:::danger  
 You should never share a client secret or commit it to source control.  
:::

:::tip  
 We recommend storing client secrets as environment variables.  
:::

## Step 2: Decode your app's client secret

Canva provides your app's client secret as a base64url-encoded string. Before you can calculate a signature with this secret, you must decode the secret into a _byte array_.

To do this, first replace all `-` characters with `+` characters and all `_` characters with `/` characters:

```javascript
const secret = process.env.CLIENT_SECRET;
const string = secret.replace("-", "+").replace("_", "/");
```

This ensures that the string is decoded as a base64url-encoded string (and not as a base64-encoded string).

Then decode the string with the `Buffer.from` method:

```javascript
const secret = process.env.CLIENT_SECRET;
const string = secret.replace("-", "+").replace("_", "/");
const key = Buffer.from(string, "base64");
console.log(key);
```

:::note  
 To learn how to decode a client secret in a range of different languages, refer to [Decoding a client secret](./decode-client-secret.md).  
:::

## Step 3: Create a message

To verify that a request signature was generated by Canva, an app must calculate the signature itself. This requires two ingredients: a _key_ and a _message_.

The key is the decoded client secret (described above).

In a `POST` request, the message is a colon-separated string that contains the following values:

### Version

The version of the API. The current version is `v1`.

### Timestamp

The timestamp of when the request was sent. This timestamp is provided as the `X-Canva-Timestamp` HTTP Header.

### Path

The path that Canva has appended to the extension's **Endpoint URL**, such as `/content/resources/find` or `/publish/resources/upload`.

### Body

The raw, unserializedÂ body of the request. (This is the body of the request _before_ it's parsed as JSON.)

:::warning  
 Some web frameworks, such as Express.js, automatically deserialize incoming request bodies. You'll need to bypass this functionality to access the raw body of the request.  
:::

This snippet demonstrates how to construct a message for a `POST` request:

```javascript
const express = require("express");

const app = express();

// This middleware is required to access the raw body of requests
app.use(
  express.json({
    verify: (request, response, buffer) => {
      const version = "v1";
      const timestamp = request.headers["X-Canva-Timestamp"];
      const path = request.path;
      const body = buffer.toString();
      const message = `${version}:${timestamp}:${path}:${body}`;
      console.log(message);
    },
  })
);

app.post("/content/resources/find", async (request, response) => {
  // code goes here
});

app.listen(process.env.PORT || 3000);
```

...and this is an example of a message for a `POST` request:

    v1:1586167939:/content/resources/find:{"user":"AXqAwpfw2GuMaXL9-zBB8LKhViH6JTO068_8XTXjaJE=","brand":"AXqAwpfm9BvNmaakx13Cz_r13DTeRea9hWZt09b_u7s=","label":"CONTENT","limit":8,"query":"","locale":"en-GB","type":"EMBED"}

## Step 4: Calculate a request signature

When you have a key and a message, you can use these values to calculate a SHA-256 hash and convert the hash into a hex-encoded string. The resulting string is the signature for the request.

To do this, import the `createHmac` function from the `crypto` module:

```javascript
const { createHmac } = require("crypto");
```

Create a `Hmac` object with the `createHmac` method, passing through `"sha256"` as the first argument and the key as the second argument:

```javascript
const signature = createHmac("sha256", key);
```

Call the `update` method on the `Hmac` object, with the message as the only argument:

```javascript
const signature = createHmac("sha256", key).update(message);
```

Then convert the `Hmac` object into a hex-encoded string:

```javascript
const signature = createHmac("sha256", key).update(message).digest("hex");
console.log(signature);
```

## Step 5: Compare the signatures

When Canva sends a `POST` request to an app, it includes a comma-separated list of request signatures in the HTTP headers, via the `X-Canva-Signatures` header.

If the calculated signature is **not** found in the list of signatures, the request did not originate from Canva and the app should reject the request with a `401` status code:

```javascript
// Reject requests with invalid signatures
if (!request.headers["X-Canva-Signatures"].includes(signature)) {
  console.log("The signature is NOT valid");
  response.sendStatus(401);
}
```

## Example

:::note  
 This example only demonstrates how to verify request signatures. Your app also needs to [verify the timestamps](./verify-timestamp.md) of each request.  
:::

```javascript
const { createHmac } = require("crypto");
const express = require("express");

const app = express();

// This middleware is required to access the raw body of requests
app.use(
  express.json({
    verify: (request, response, buffer) => {
      // Load the secret from an environment variable
      const secret = process.env.CLIENT_SECRET;

      // Decode the client secret
      const string = secret.replace("-", "+").replace("_", "/");
      const key = Buffer.from(string, "base64");

      // Construct the message
      const version = "v1";
      const timestamp = request.headers["X-Canva-Timestamp"];
      const path = request.path;
      const body = request.body;
      const message = `${version}:${timestamp}:${path}:${body}`;

      // Calculate a signature
      const signature = createHmac("sha256", key).update(message).digest("hex");

      // Reject requests with invalid signatures
      if (!request.headers["X-Canva-Signatures"].includes(signature)) {
        console.log("The signature is NOT valid");
        response.sendStatus(401);
      }
    },
  })
);

app.post("/content/resources/find", async (request, response) => {
  // Handle requests with valid signatures
  console.log("The signature is valid");
});

app.listen(process.env.PORT || 3000);
```
